[ { "title": "HackCTF RTL_core", "url": "/posts/HackCTF-RTL_core/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-04-05 17:00:00 +0900", "snippet": "RTL_coreSource➜ RTLcore git:(master) ✗ checksec --file rtlcore[*] &#39;/home/ubuntu/CTF/hackctf/pwnable/RTLcore/rtlcore&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ssize_t core(){ int buf; // [es..." }, { "title": "HackCTF 1996", "url": "/posts/HackCTF-1996/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-04-02 17:00:00 +0900", "snippet": "1996Source➜ pwnable git:(master) ✗ checksec --file 1996[*] &#39;/home/ubuntu/CTF/hackctf/pwnable/1996&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)int spawn_shell(void){ char *argv[2]; // [rsp+0h]..." }, { "title": "HackCTF Smooth CipherText", "url": "/posts/HackCTF-Smooth_CipherText/", "categories": "WriteUp, Crypto", "tags": "WriteUp, HackCTF, Crypto", "date": "2021-04-02 17:00:00 +0900", "snippet": "Smooth CipherTextSourceRijvsmysmysmy Itovwyrc! Ns wyy ixsu Glm kq G? wc lkqc sw qwsmdlkkr sr...M ixsu fipi acvp urer iss geld! Md iss mel niastfov rrmq mvwzxmqvyw, cme gyx kcd xfo gmbvcmx yxwuov. qy, jjkk gc LymoADJ{t_tzwi_3vxbd0p3_vff.afy&#39;q_wzoxpq_dp_qfz}Solve처음엔 단순한 Caesar 암호인줄알았는데 아니었다. 그럼..." }, { "title": "HackCTF g++ pwn", "url": "/posts/HackCTF-g++_pwn/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-04-01 17:00:00 +0900", "snippet": "g++ pwn➜ pwnable git:(master) ✗ checksec --file gpwn[*] &#39;/home/ubuntu/CTF/hackctf/pwnable/gpwn&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)Sourceint get_flag(){ return system(&quot;cat flag.t..." }, { "title": "HackCTF Poet", "url": "/posts/HackCTF-Poet/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-04-01 17:00:00 +0900", "snippet": "PoetSourcevoid __noreturn reward(){ char s[136]; // [rsp+0h] [rbp-90h] BYREF FILE *stream; // [rsp+88h] [rbp-8h] stream = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); fgets(s, 128, stream); printf(format, &amp;amp;author, s); exit(0);}int rate_poem(){ char dest[1032]; // [rsp+0h] [rbp-410..." }, { "title": "HackCTF 내 버퍼가 흘러넘친다!!!", "url": "/posts/HackCTF-%EB%82%B4_%EB%B2%84%ED%8D%BC%EA%B0%80_%ED%9D%98%EB%9F%AC%EB%84%98%EC%B9%9C%EB%8B%A4!!!/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "내 버퍼가 흘러넘친다!!!Sourcechar name[50];int __cdecl main(int argc, const char **argv, const char **envp){ char s[20]; // [esp+0h] [ebp-14h] setvbuf(stdout, 0, 2, 0); printf(&quot;Name : &quot;); read(0, &amp;amp;name, 50u); printf(&quot;input : &quot;); gets(s); return 0;}Solvefrom pwn import *#..." }, { "title": "HackCTF x64 yes_or_no", "url": "/posts/HackCTF-yes_or_no/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "yes_or_noSourceint __cdecl main(int argc, const char **argv, const char **envp){ int v3; // eax int v4; // eax int v5; // ecx int v6; // eax int v7; // eax char s[10]; // [rsp+Eh] [rbp-12h] int v10; // [rsp+18h] [rbp-8h] int v11; // [rsp+1Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); v11 =..." }, { "title": "HackCTF x64 Simple_size_BOF", "url": "/posts/HackCTF-x64_Simple_size_BOF/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "x64 Simple_size_BOFSourceint __cdecl main(int argc, const char **argv, const char **envp){ char v4[27952]; // [rsp+0h] [rbp-6D30h] setvbuf(_bss_start, 0LL, 2, 0LL); puts(s); printf(&quot;buf: %p\\n&quot;, v4); gets(v4); return 0;}Solvefrom pwn import *#context.log_level = &#39;DEBUG&#39;cont..." }, { "title": "HackCTF x64 Buffer Overflow", "url": "/posts/HackCTF-x64_Buffer_Overflow/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "x64 Buffer OverflowSourceint __cdecl main(int argc, const char **argv, const char **envp){ char s[268]; // [rsp+10h] [rbp-110h] int v5; // [rsp+11Ch] [rbp-4h] _isoc99_scanf(&quot;%s&quot;, s, envp); v5 = strlen(s); printf(&quot;Hello %s\\n&quot;, s); return 0;}Solvefrom pwn import *#context...." }, { "title": "HackCTF strncmp", "url": "/posts/HackCTF-strncmp/", "categories": "WriteUp, Reversing", "tags": "WriteUp, HackCTF, Reversing", "date": "2021-03-31 17:00:00 +0900", "snippet": "strncmpSourceint __fastcall check(int a1, const char **a2){ int v3; // [rsp+1Ch] [rbp-4h] v3 = atoi(a2[1]); if ( v3 * (v3 - 14) == -49 ) key = v3; else key = 0; return main(a1, a2, a2);}int __cdecl main(int argc, const char **argv, const char **envp){ char v4; // [rsp+20h] [rbp-50h] ..." }, { "title": "HackCTF rtl_world", "url": "/posts/HackCTF-rtl_world/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "rtl_worldSourceint Get_Money(){ int result; // eax int v1; // [esp+8h] [ebp-Ch] int v2; // [esp+Ch] [ebp-8h] int v3; // [esp+10h] [ebp-4h] puts(&quot;\\nThis world is F*cking JabonJui&quot;); puts(&quot;1) Farming...&quot;); puts(&quot;2) Item selling...&quot;); puts(&quot;3) Hunting...&qu..." }, { "title": "HackCTF keygen", "url": "/posts/HackCTF-keygen/", "categories": "WriteUp, Reversing", "tags": "WriteUp, HackCTF, Reversing", "date": "2021-03-31 17:00:00 +0900", "snippet": "keygenSource_BYTE *__fastcall encoding(const char *a1){ unsigned __int8 v2; // [rsp+1Fh] [rbp-11h] int i; // [rsp+20h] [rbp-10h] int v4; // [rsp+24h] [rbp-Ch] _BYTE *v5; // [rsp+28h] [rbp-8h] v5 = malloc(0x40uLL); v4 = strlen(a1); v2 = 72; for ( i = 0; i &amp;lt; v4; ++i ) { v5[i] = (..." }, { "title": "HackCTF handray", "url": "/posts/HackCTF-handray/", "categories": "WriteUp, Reversing", "tags": "WriteUp, HackCTF, Reversing", "date": "2021-03-31 17:00:00 +0900", "snippet": "handraySourcepush rbpmov rbp,rspsub rsp,0x10mov DWORD PTR [rbp-0x4],0x0cmp DWORD PTR [rbp-0x4],0x1jne 0x40058d &amp;lt;main+103&amp;gt;mov DWORD PTR [rbp-0x8],0x0jmp 0x400571 &amp;lt;main+75&amp;gt;mov eax,DWORD PTR [rbp-0x8]cdqemovzx eax,BYTE PTR [rax+0x6010e0]mov e..." }, { "title": "HackCTF bof_pie", "url": "/posts/HackCTF-bof_pie/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "bof_pieSourcevoid j0n9hyun(){ char s; // [esp+4h] [ebp-34h] FILE *stream; // [esp+2Ch] [ebp-Ch] puts(&quot;ha-wi&quot;); stream = fopen(&quot;flag&quot;, &quot;r&quot;); if ( stream ) { fgets(&amp;amp;s, 40, stream); fclose(stream); puts(&amp;amp;s); } else { perror(&quot;fla..." }, { "title": "HackCTF Simple_overflow_ver_2", "url": "/posts/HackCTF-Simple_overflow_ver_2/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "Simple_overflow_ver_2Sourceint __cdecl main(int argc, const char **argv, const char **envp){ size_t v3; // ebx char v5; // [esp+13h] [ebp-89h] char s[128]; // [esp+14h] [ebp-88h] int i; // [esp+94h] [ebp-8h] setvbuf(stdout, 0, 2, 0); v5 = &#39;y&#39;; do { printf(&quot;Data : &quot;); ..." }, { "title": "HackCTF Reversing Me", "url": "/posts/HackCTF-Reversing_Me/", "categories": "WriteUp, Reversing", "tags": "WriteUp, HackCTF, Reversing", "date": "2021-03-31 17:00:00 +0900", "snippet": "Reversing MeSource#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int main() { int i; char *serial = &quot;H`cjCUFzhdy^stcbers^D1_x0t_jn1w^r2vdrre^3o9hndes1o9&amp;gt;}&quot;; char enter[54]; printf(&quot;키를 입력하시게 : &quot;); scanf(&quot;%s&quot;, enter); if (strlen(enter) == strle..." }, { "title": "HackCTF Offset", "url": "/posts/HackCTF-Offset/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "OffsetSourceint print_flag(){ char i; // al FILE *fp; // [esp+Ch] [ebp-Ch] puts(&quot;This function is still under development.&quot;); fp = fopen(&quot;flag.txt&quot;, &quot;r&quot;); for ( i = _IO_getc(fp); i != -1; i = _IO_getc(fp) ) putchar(i); return putchar(10);}int two(){ return ..." }, { "title": "HackCTF Great Binary", "url": "/posts/HackCTF-Great_Binary/", "categories": "WriteUp, Crypto", "tags": "WriteUp, HackCTF, Crypto", "date": "2021-03-31 17:00:00 +0900", "snippet": "Great BinarySource01001000 01100001 01100011 01101011 01000011 01010100 01000110 01111011 01100011 01110010 01111001 01110000 01110100 01101111 01011111 01110110 00110010 01110010 01111001 01011111 01100101 01100001 01110011 01111001 01011111 01110000 01110010 00110000 01100010 00110001 01100101 ..." }, { "title": "HackCTF Classic Cipher - 2", "url": "/posts/HackCTF-Classic_Cipher-2/", "categories": "WriteUp, Crypto", "tags": "WriteUp, HackCTF, Crypto", "date": "2021-03-31 17:00:00 +0900", "snippet": "Classic Cipher - 2SourceHint : Key is Number➜ crypto git:(master) ✗ cat ╣о┴ж.txtThis is simple transposition cipherkey is &quot;python&quot;Ciphertext is hreCp1_ev_s117nr_ys17eer132n_5Solve난 이 문제를 보고 디코드겠거니 생각하고 여러 디코더를 돌렸다. 하지만 모두 실패였다.알고보니 전치암호 라는 것이었다.힌트에서 준 것은 “python”6글자이며 알파벳 순서대로 번호를 매기면+..." }, { "title": "HackCTF Classic Cipher - 1", "url": "/posts/HackCTF-Classic_Cipher-1/", "categories": "WriteUp, Crypto", "tags": "WriteUp, HackCTF, Crypto", "date": "2021-03-31 17:00:00 +0900", "snippet": "Classic Cipher - 1SourceHint : [::-1]?y4zl4J_d0ur_b0f_0K zp nhsmSolve우선 힌트를 가지고 해당 텍스트를 반대로 출력해봤다.string = &quot;&quot;with open(&quot;Cipher.txt&quot;, &quot;rb&quot;) as f: string = f.read()print string[::-1]f.close()mshn pz K0_f0b_ru0d_J4lz4y?무슨 물음같은데 정공법대로 Caesar 부터 돌린다.import stringdef sub_E..." }, { "title": "HackCTF Basic FSB", "url": "/posts/HackCTF-Basic_FSB/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "Basic FSBSourceint flag(){ puts(&quot;EN)you have successfully modified the value :)&quot;); puts(aKr); return system(&quot;/bin/sh&quot;);}int vuln(){ char s[1024]; // [esp+0h] [ebp-808h] char format; // [esp+400h] [ebp-408h] printf(&quot;input : &quot;); fgets(s, 1024, stdin); snprintf(..." }, { "title": "HackCTF Basic BOF #2", "url": "/posts/HackCTF-Basic_BOF_-2/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "Basic BOF #2Sourcent __cdecl main(int argc, const char **argv, const char **envp){ char s[80]; // [esp+Ch] [ebp-8Ch] void (*v5)(void); // [esp+8Ch] [ebp-Ch] v5 = (void (*)(void))sup; fgets(s, 133, stdin); v5(); return 0;}Solvefrom pwn import *e = ELF(&quot;./bof_basic2&quot;)#p = process(&q..." }, { "title": "HackCTF Basic BOF #1", "url": "/posts/HackCTF-Basic_BOF_-1/", "categories": "WriteUp, Pwnable", "tags": "WriteUp, HackCTF, Pwnable", "date": "2021-03-31 17:00:00 +0900", "snippet": "Basic BOF #1Sourceint __cdecl main(int argc, const char **argv, const char **envp){ char s[40]; // [esp+4h] [ebp-34h] int v5; // [esp+2Ch] [ebp-Ch] v5 = 0x4030201; fgets(&amp;amp;s, 45, stdin); printf(&quot;\\n[buf]: %s\\n&quot;, &amp;amp;s); printf(&quot;[check] %p\\n&quot;, v5); if ( v5 != ..." } ]
